1. Factorial program in JAVA- 
int fact= 1;
int number=4;

for(int i=1; i<=number; i++){
 fact= fact*i
}
System.out.println(fact);
 



2. String Reverse - Char and the whole string statements - 

public void stringRevers() {
		String name= "Sushant Pawar";
		
		
		StringBuilder newString= new StringBuilder();
		
		newString.append(name);
		
		newString.reverse();
		
		System.out.println(newString);
}

 #Using toCharArray() - Which crate array of the char 
 
 char[] name= string.toCharArray(); //created name array of char 
 
 public void StringCharReverse() {
		String name= "Sushant";
		String finalResult= "";
		
		char[] reverThisString= name.toCharArray();
		System.out.println(reverThisString.length);
		
		for(int i=reverThisString.length-1; i>=0; i--) {
			
		
			
			finalResult=finalResult+reverThisString[i];  
			
		}
		
		System.out.println(finalResult);
	}
 
 
#3. Add two number - 
int num=2;
int tonum=3;
int sum= num+toNum;
SYSO(sum);


#4. Print dublicate numbers showing in array 
public void displaySameNUmbers() {
		int [] number={10, 20, 10, 30, 40, 10, 50, 20, 60};
		
		for(int i=0; i<=number.length-1; i++) {
			for(int j=i+1;j<=number.length-1; j++) {
				if(number[i]==number[j]) {
					System.out.println(number[j]);
				}
				
			}
			
		}
    
    
    
#5. Types of exception in the automation you faced- 

#6. Abstract Class - can't create object of abract class BUT it can access using inteheritance we can extends the absract class, 
then abstract method can only written in abstract class 

#7. What are the different types of string methods 

#8. What is collections? what collections you have used?

#9. What is interface and abstact class 

#10. Method overloading and method overriding - 
A. Method Overloading - Complie time polymorphism, may or may not inheritance required here 
  Same method name with different parameters 

class Adder{  
static int add(int a,int b){return a+b;}  
static int add(int a,int b,int c){return a+b+c;}  
}  
class TestOverloading1{  
public static void main(String[] args){  
System.out.println(Adder.add(11,11));  
System.out.println(Adder.add(11,11,11));  
}}   

B. Method Overriding - Run time polymorphism, required the inheritance 
Same method name with same parameters 
//Java Program to illustrate the use of Java Method Overriding  
//Creating a parent class.  
class Vehicle{  
  //defining a method  
  void run(){System.out.println("Vehicle is running");}  
}  
//Creating a child class  
class Bike2 extends Vehicle{  
  //defining the same method as in the parent class  
  void run(){System.out.println("Bike is running safely");}  
  
  public static void main(String args[]){  
  Bike2 obj = new Bike2();//creating object  
  obj.run();//calling method  
  }  
}  




#11. How you will type in textfied without using sendkeys - 
JavascriptExecutor js= (JavascriptExecutor)driver;
js.executeScript ("document.getElementById('gsc-i-id1').value='Selenium'");

#12. Access modifier - 


#13. How many browser you can use for automation

#14. Parallel testing using testNG

#15. Fluent Wait - ??

Default polling time is 500 milliseconds which is 0.5 seconds 

Hard wait - Thread.sleep (20), driver get sleep until 20 milliseconds even next action element shows

Implicitly wait - Tell driver to wait until post the error No such element present if present then go ahead quickly for next action element 

Explicit wait - Wait until that element is clickable - or visible or alertPresent () - elementToBeClickable() or visibilityOfElementLocatedBY(locator) OR 

#16. Difference between throw and throws - 

A. Throw - We can explicitly adding an exception here 
Eg, for 
Public class CheckNUmber(){
If (number<1){
throw new ArithmeticException (“Number can not be negative”)
}else{
System.out.println(“This is the nubmber”+ number);
}
}

B. Throws - This is used for a method on which exception can comes 
Public class CheckDevideBy() throws ArithmeticException {
Int div= t/n;
Return div;
}

#17. #Difference in Final, finally
Final- 
(1) Once declared, final variable becomes constant and cannot be modified.
(2) final method cannot be overridden by sub class.
(3) final class cannot be inherited.

Finally- 
(1) finally block runs the important code even if exception occurs or not. it's uses after exception ocuured 


#18. This and super keyword in java - 
A. super keyword is used to access methods of the parent class - 
If super class method is A() then we can use super.A() - mening calling super class method A


B. while this is used to access methods of the current class - 
public class A{
int a=200;
public void method(){
this.a= 100
}
}

#19. Type Casting in JAVA - 
#double - Big Size data type that int 
Then if any to covert the double to int then we need to add syntax (Narrowing)
double value= 19.99;
		int numverValue= (int) value;
		System.out.println(numverValue); // result will be 19



Widening - from lover data type to higher datatype - 
	int num= 10;
		double numVale= num;
		System.out.println(numVale); //result will be 10.00
		
		

