1. Factorial program in JAVA- 
int fact= 1;
int number=4;

for(int i=1; i<=number; i++){
 fact= fact*i
}
System.out.println(fact);
 



2. String Reverse - Char and the whole string statements - 

public void stringRevers() {
		String name= "Sushant Pawar";
		
		
		StringBuilder newString= new StringBuilder();
		
		newString.append(name);
		
		newString.reverse();
		
		System.out.println(newString);
}

 #Using toCharArray() - Which crate array of the char 
 
 char[] name= string.toCharArray(); //created name array of char 
 
 public void StringCharReverse() {
		String name= "Sushant";
		String finalResult= "";
		
		char[] reverThisString= name.toCharArray();
		System.out.println(reverThisString.length);
		
		for(int i=reverThisString.length-1; i>=0; i--) {
			
		
			
			finalResult=finalResult+reverThisString[i];  
			
		}
		
		System.out.println(finalResult);
	}
 
 
#3. Add two number - 
int num=2;
int tonum=3;
int sum= num+toNum;
SYSO(sum);


#4. Print dublicate numbers showing in array 
public void displaySameNUmbers() {
		int [] number={10, 20, 10, 30, 40, 10, 50, 20, 60};
		
		for(int i=0; i<=number.length-1; i++) {
			for(int j=i+1;j<=number.length-1; j++) {
				if(number[i]==number[j]) {
					System.out.println(number[j]);
				}
				
			}
			
		}
    
    
    
#5. Types of exception in the automation you faced- 
Checked & unchecked expection - 

A. Checked expection - When file not found we use this when reading file - eg- 
We use this while loading the properties file - config.properties 

public void readPropertyTest() throws IOException {
 Properties pro= new Properties();
 FileInputStream io= new FileInputStream("/Users/sushant/eclipse-workspace/SeleniumQA/src/test/java/demo/config.properties"); //FileNotFoundException
 pro.load(io); //IO Exceptions - Input Output operation failed exceptions 
 
}

B. unchecked expection - 
Array out of bound OR ElementNotVisibleException, EG- 

driver.findElement(By.id("submit")).click();
Exception Handling:
 
try {
driver.findElement(By.id("submit")).click();
} catch (NoSuchElementException e)

Selenium exception - 
NoSuchElement exception 
ElementNotVisible
ElementNotClickable 
ElementNotSelectableException
TimeoutException
NoSuchFrameExceptionc

Some More Example of Expections - 

try {
driver.switchTo().frame("frame_11");
} catch (NoSuchFrameException e)


try {
driver.switchTo().alert().accept();
} catch (NoSuchAlertException e)




#6. Abstract Class - can't create object of abract class BUT it can access using inteheritance we can extends the absract class, 
then abstract method can only written in abstract class 

#7. What are the different types of string methods - 
compare(), concat(), equals(), split(), length(), replace(), compareTo(), intern(), substring() 

char[] ch={'j','a','v','a','t','p','o','i','n','t'};  //covert the char array to string 
String s=new String(ch); 
SYSO (s)// javapoints;




#8. What is collections? what collections you have used? -
Collection of the objects using array, arraylist, hasMap, Set 

Array - Size is defined and can’t modified 

ArrayList - We can modified the size of the array 

Array List Syntax- 
ArrayList <String> name= new  ArrayList<String>();

ArrayList methods- 
Add elements to array
Name.add(“SUSH”);
Name.add(“KISH”);
Name.add(“ROH”);

Access Array List elements - 
Name.get(0) //to get the first element in arraylst

Size of array list- 
Name.size();

Modifiye arraylist 
Name.set(0, “Ketan”);

Also .remove (0) or we can clear array list by name.clear();

#ArrayList and LinkedList is almost same, just for array list- it stores the data in array and if array is big then it remove the old array and create new big array however for linked list it create containers, and if linked with other container it not removes the first containers 

Some methods for LinkedList - addFirst(), getFirst(), getLast()


HashMap - 
#HashMap - Key, Value pair
HashMap <String, String> names= new HashMap <String, String> (); //intilaize the hashmap of string
To map the key value pair (“India”, “Mumbai”)

HashMap <Integer, String> names= new HashMap <String, String> (); //intilaize the hashmap of Integer and String 
To map the key value pair (1, “Mumbai”)

Names.put(“1”, “First Number”); //to put the key and value in HashMap 

Names.get(1) //Enter the key here it will give you the value as result, ie. Mumbai

To print the the key only - 
For(int I: name.keySet()){
SYSO(i)
}

To print the the value - 
For(String I: name.values()){
SYSO(i)
}


#9. What is interface and abstact class - (Both are used to do data abstractions)
Data abstraction is the process of hiding certain details and showing only essential information to the user.

Abstraction can be done using the absraction class and interface 

Abraction Class- We can not create an object of the abstraction class, abstract method can use only in abstarct class & abstraction method dose not have a body
the body can written in the subcalss that calling the abstarct method using inheritance 

// Abstract class - 

abstract class Animal {
  
  public abstract void animalSound();  // Abstract method (does not have a body)

  public void sleep() {       // Regular method
    System.out.println("Zzz");
  }
}


class Pig extends Animal {       // Subclass (inherit from Animal)
  public void animalSound() {
    
    System.out.println("The pig says: wee wee");      //// The body of animalSound() is provided here
  }
}

class Main {
  public static void main(String[] args) {
    Pig myPig = new Pig(); // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}


Abstraction can also done using the interface - 


interface Animal {     // Interface
  public void animalSound();   // interface method (does not have a body)
  public void sleep();    // interface method (does not have a body)
}

// Pig "implements" the Animal interface
class Pig implements Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
  public void sleep() {
    // The body of sleep() is provided here
    System.out.println("Zzz");
  }
}

class Main {
  public static void main(String[] args) {
    Pig myPig = new Pig();  // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}


We using inteface class of ITlistner and implements that in our listner class where we can use that interface methods such as OnTestFailed() and write our code 
like to print message after test case get failed or screenshot methods  


#10. Method overloading and method overriding - 
A. Method Overloading - Complie time polymorphism, may or may not inheritance required here 
  Same method name with different parameters 

class Adder{  
static int add(int a,int b){return a+b;}  
static int add(int a,int b,int c){return a+b+c;}  
}  
class TestOverloading1{  
public static void main(String[] args){  
System.out.println(Adder.add(11,11));  
System.out.println(Adder.add(11,11,11));  
}}   

B. Method Overriding - Run time polymorphism, required the inheritance 
Same method name with same parameters 
//Java Program to illustrate the use of Java Method Overriding  
//Creating a parent class.  
class Vehicle{  
  //defining a method  
  void run(){System.out.println("Vehicle is running");}  
}  
//Creating a child class  
class Bike2 extends Vehicle{  
  //defining the same method as in the parent class  
  void run(){System.out.println("Bike is running safely");}  
  
  public static void main(String args[]){  
  Bike2 obj = new Bike2();//creating object  
  obj.run();//calling method  
  }  
}  





#11. How you will type in textfied without using sendkeys - 
JavascriptExecutor js= (JavascriptExecutor)driver;
js.executeScript ("document.getElementById('gsc-i-id1').value='Selenium'");

#12. Access modifier - 

Private - Only can use within the class, not outside the class and outside the package 
Public - Can use outside the class and outside the package 
Protected - can access within the class as well as outside the class of same package not the outside package class, it can access outside the package only when
it inheriate from the that class where it is declared using extends 
Default - when no any data type is provide it set to default, it can access within the class and withing the same package can't access outside the class even
it inheriate from the that class where it is declared using extends 

Inorder to use our varibale to the private varibale of other class we can use getter and settler - 

Private string name= "Sushant";

public void getter(String name)
 this.name= name;
 
 public void setter(){
 SYSO(name);
 }



#13. How many browser you can use for automation -


#14. Parallel testing using testNG - 


#15. Fluent Wait - ?? - 

Default polling time is 500 milliseconds which is 0.5 seconds 

Hard wait - Thread.sleep (20), driver get sleep until 20 milliseconds even next action element shows

Implicitly wait - Tell driver to wait until post the error No such element present if present then go ahead quickly for next action element 

Explicit wait - Wait until that element is clickable - or visible or alertPresent () - elementToBeClickable() or visibilityOfElementLocatedBY(locator) OR 

#16. Difference between throw and throws - 

A. Throw - We can explicitly adding an exception here 
Eg, for 
Public class CheckNUmber(){
If (number<1){
throw new ArithmeticException (“Number can not be negative”)
}else{
System.out.println(“This is the nubmber”+ number);
}
}

B. Throws - This is used for a method on which exception can comes 
Public class CheckDevideBy() throws ArithmeticException {
Int div= t/n;
Return div;
}

#17. #Difference in Final, finally
Final- 
(1) Once declared, final variable becomes constant and cannot be modified.
(2) final method cannot be overridden by sub class.
(3) final class cannot be inherited.

Finally- 
(1) finally block runs the important code even if exception occurs or not. it's uses after exception ocuured 


#18. This and super keyword in java - 
A. super keyword is used to access methods of the parent class - 
If super class method is A() then we can use super.A() - mening calling super class method A


B. while this is used to access methods of the current class - 
public class A{
int a=200;
public void method(){
this.a= 100
}
}

#19. Type Casting in JAVA - 
#double - Big Size data type that int 
Then if any to covert the double to int then we need to add syntax (Narrowing)
double value= 19.99;
		int numverValue= (int) value;
		System.out.println(numverValue); // result will be 19



Widening - from lover data type to higher datatype - 
	int num= 10;
		double numVale= num;
		System.out.println(numVale); //result will be 10.00
		
		
		
#20. Types of Polymorphism - 
	 Many forms - we can user our super class methods for another user,
	 we can user superclass methods and write our code in it, 
	 single action/method can be performed in different ways to perform differently
	 
	 A. Static (Compile time polyorphism) - 
	 Same name method but with different parameters 
	 Class A{
	 methodAdd(1,2)
	 methodAdd(1,2,3)
	 }
	 
	 Class B{
	 public static void main(String [] args){
	 A obj= new A();
	 obj.methodAdd(1,2);
	 obj.methodAdd(1,2,3);
	 
	 }
	 }
	 
	 
	 
	 B. Dynamic (Run time polymorphism)- 
	 We use Upcasting here Create object of super class which refere the sub class 
	 
	 Class A{
	 public void Myname(){
	 "My name is Rahul"
	 }
	 
	 }
	 
	 Class B extends A{
	 public void Myname(){
	 "My name is Sushant"
	 }
	 
	 }
	 
	 
	 Class C{
	 public static void main(String [] args){
	 A obj= new B();// Upcasting    We use Upcasting here Create object of super class which refere the sub class 
	 obj.Myname(); - Output will be sushant 
	 
	 
	 }
	 
#21. Encapsulation and common use cases - 
The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from users

We need to declare that as a private as we cant access private varibale/methods outside the class

BUT we can access those private attributes using get and set methods 

Class A{
Private String name;
//Getter 

public String getName(){
return name;
}

//Setter
public void setName(String newName){
this.name= newName;
}

}


public class Main {
  public static void main(String[] args) {
    Person myObj = new Person();
    myObj.setName("John"); // Set the value of the name variable to "John"
    System.out.println(myObj.getName());
  }
}


#22. Can I write try catch without the catch block?
Yes using finally block it will always excute finally 


#23. How to prevent a class from being sub classes?
- 
public final class A
{

}

#24. Static block and instance block 
static blocks executes before instance blocks in java
Also, static blocks are executed before constructors

		
#25. To find the same char of the string and it's count - 
public void checkChar() {
		String name= "SuShanSt";
		int count;
		
		char [] nameQA= name.toCharArray();
		count=0;
		for(int i=0; i<nameQA.length; i++) {
			
			for(int j=i+1; j<nameQA.length;j++) {
				if(nameQA[i]==nameQA[j]) {
					System.out.println(nameQA[j]);
					count= count+1;
				}
			}
		}System.out.println(count);
		
	}

#26. prime number -  Conditon [number% (2 to number) ==0] should not satisfield 

public void checkChar() {
		
		int num= 30;
		boolean flag= false;
		
		for(int i=2; i<num; i++) {
			
			if(num%i==0) {
				flag=true;
				break;
			}
		}
		
		if(!flag) {
			System.out.println("This is prime number");
		}else {
			System.out.println("This is not a prime number");
		}
	
		
	}


#27. Scrolling horizontally and vertically 

JavascriptExecutor js = (JavascriptExecutor) driver;

js.executeScript("window.scrollBy(x-pixels,y-pixels)");


#28. JDK 1.8 onwards & JAVA 8 - have a new feature on which we can write body to interface methods using default and static 
And can call them after implements and then extend the class where it implements 


#29. Multiple inheritance - Java dose not support the multiple inheritance such as - 
Class A
  
Class B 


Class C extends A, B // not allowed multiple inheritance 


So overcome this problem using interface & after java 8 and JDK 1.8 we can enter the methods default and static to our interface and can implements multiple time 

Interface A

Interface B 

Interface A implements A, B 

Call the methods without 




#28. Singleton class - A Singleton class in Java allows only one instance to be created and provides global access to all other classes through this single object or instance.


#29. GitHub - 

Go to Github - Add our GitHub repository URL -Github Repository will show in eclipse

Now Copy our project to that GitHub repository from our machine, then that project will show in eclipse repo

Then Write click on project - Team - Share project - Git Staging - Copy all files and paste to staged changes then commit and push - add unmet/pwd - then GitHub site will show the project 

Pull the branch master if someone make commits on the master so latest master can pulled 

Create different branches on GitHub and we can also pull those by Team- Switch to - Branch name

Add commit using Team - Commit - Staging Commit - drag drop the unstated changed file into Staged changes then push and commit 

We can merge the branch into master branch by - Team - Merge into Master 

#30. Which things can’t you automate 
* Automating Captcha is not possible using Selenium WebDriver.
* We can not read bar code using Selenium WebDriver.


#31. Web driver Listner & testNg Listner when to used 

Challenges  facing while automation - 
Timeout page - PagetimeOut as default time is 500 milliseconds from web driver to find elements so we used the pageLoad time 

Elements not clickable - Those are visible but no clickable, it take some time to click such elements, so we used the explicit time condition 

Po ups handling - We users the Alert function here to handle the popups
