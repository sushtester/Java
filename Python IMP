print("Hello world")
a=100
b=300
print("sum of two numbers")

.py is a extension for python source file 

##Create an object of the class to call the varibale of the class - 

class myname:
    a=100
    b="sushant"

        
obj=myname()
print(obj.b)



#Class and function call using object and paramters - 

class myname:
    a=100
    b="sushant"
    def firstMethod(self):
      print("This is the output", self.b, "My name is sushant")
        
obj=myname()
obj.b="pravin"
obj.firstMethod()

obj1=myname()
obj1.firstMethod()


#Constructer in the Python - __init__
class Person:
    def __init__(self,a,b):
        #self.a=a;
        #self.b=b;
        print("This is my first constructer", a, b)
        
obj=Person(1,2)
obj1=Person(5,9)

class Person:
    def __init__(self,a,b):
        self.a=a;
        self.b=b;
        #c=a+b
        print("This is my first constructer", a, b)
    
    def myMethod(self):
        print("First number is", self.a, "Second is", self.b)
        
obj=Person(1,2)
obj.myMethod()



#Array in the Python - 

Declaring an array - 
arr=[10, 20, 70, 40, 50]

print(arr[0])

find the length of the array - 
class ArrayLearn:
    array=[10, 30, 40, 20, 50]
    print(len (array))

Adding element into array - 
append - 
class ArrayLearn:
    array=[10, 30, 40, 20, 50]
    print(len (array))
    array.append(70)
    print(array)

concat - 
class ArrayLearn:
    array=[10, 30, 40, 20, 50]
    print(len (array))
    array=array+[70, 80, 90, 90]
    print(array)

Removing element from array - 
class ArrayLearn:
    array=[10, 30, 40, 20, 50]
    print(array)
    print(array[0])
    array.remove(40);
    print(array)
    del array[1]
    print(array)

pop()- 
class ArrayLearn:
    array=[10, 30, 40, 20, 50]
    print(len (array))
    array=array+[70, 80, 90, 90]
    print(array)
    
    array.pop(0)
    
    print(array)

array[-1] means the last element of the array, we can replace that - 
array[-1]= 40  // it will replace the last element 

#File methods in the python - 

close - 

detach - 

fileno - 

flush - 

isatty - 

read(n)- 

readable - 


#For loop in Python - 
in range for numbers- 
class ArrayLearn:
    def nameForLoopExample(self):
        for i in range (1, 10):
            if(i==8):
                print(i)
                break
            
obj= ArrayLearn()
obj.nameForLoopExample()

in string name or in array can use for string for loop - 

class ArrayLearn:
    
    def nameForLoopExample(self):
        name="sushant"
        for i in name:
            if(i=="h"):
                print(i)
                break
            
obj= ArrayLearn()
obj.nameForLoopExample()

class ArrayLearn:
    
    def nameForLoopExample(self):
        nameArray= ["sushant", "pawar", "tambave", "karad"]
        for i in nameArray:
            print(i)
            for n in i:
                print(n)
            
                
obj= ArrayLearn()
obj.nameForLoopExample()

#Python keywords and identifiers - 
keywords are case-sensitive in the python 

True and false - 

None - kind of null 

assert 

break 

continue 

if, elif, else

try, raise, catch, finally

global variable - using keyword global - 

in - used for the condition 

lambda - 

nonlocal 

pass 

return 

while 

with 

with open - 

yield - 


#Deleting the variable from the computer memory - 
a=10
del a
print(a)  // error 


#Python Touples - 
Tuple - Touples elements immutable - can not be updated 

List - List elements are mutable

Tuple are immutable so iterating  on Tuple is faster so we can say Tuple is faster than the list 

Touples we can use the multiple data type elements mixed - mixed datatype (heterogeneous) list are homogeneous 

Touples - we can not change the elements under Tuple 

print tuple - 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar")
    print(tupleArray)

contact tuple - 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar")
    tupleAyyar2=tupleArray+(30, "Kishor", 40, "Patil")
    print(tupleAyyar2)

Tuple unpacking - Assigning value to the tuple 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar")
    id, name, password, address= tupleArray
    print(name)

Accecing elements in tuple - 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar")
    print(tupleArray[0])

slicing tuple - We can do that for the array as well in Python 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar")
    print(tupleArray[0:3])

tuple count - to find the count of the element in tuple
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar", 10)
    print(tupleArray.count(10))

tuple index -
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar", 10)
    print(tupleArray.index("sushant"))

len - find the length of the tuple 
class MyTest:
    tupleMy=(10, "sushant", "pawar", "sushantp@gmail.com", 9503967719)
    print(len(tupleMy))

in 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar", 10)
    print("sushant" in tupleArray)  // it will return True

not in 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar", 10) // It will return false
    print("sushant" not in tupleArray)

max 
class MyTest:
    tupleMy=(10, 20, 50, 5)
    print(max(tupleMy))

min 
class MyTest:
    tupleMy=(10, 20, 50, 5)
    print(min(tupleMy))

sorted 
class MyTest:
    tupleMy=(10, 20, 50, 5)
    print(sorted(tupleMy))

delete - 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar")
    del tupleArray

len 
class MyTest:
    tupleArray=(10, "sushant", 20, "pawar")
    print(len(tupleArray))

nested tuple - We can declare the tuple inside the tuple elements and get the elements 
class MyTest:
    tupleMy=(10, (20, 30, 40), ("sushant", "pawar"), 5)
    print(tupleMy[2][0])   // it will display the sushant 


#Python Sets - 
set are mutable so we can remove and add element into set under python, it's unordered and non duplicate element 
set can't be access using index set[0] //not allowed 

set declaration - set declared in the {} bracket 
class MyTest:
    set1={10, 20, 20, 60, 30, 80, 60, 40}
    print(set1)

set add value - .add()
class MyTest:
    set1={10, 20, 20, 60, 30, 80, 60, 40}
    print(set1)
    set1.add(100)
    print(set1)

set add multiple values - set1.update([100, 200])
class MyTest:
    set1={10, 20, 20, 60, 30, 80, 60, 40}
    print(set1)
    set1.update([100, 200])
    print(set1)

set remove - if we want to remove an element, need to pass the element  - set.remove(element) 

set discard - if we want to remove an element, need to pass the element set.discard(element)

Note: remove and discard is same only difference is using discard even if we entered the wrong element it will not through any error

set.clear () // to clear the set 

set union - 
class MyTest:
    set1={10, 20, 30, 40, 50}
    set2={40, 50, 60, 70, 80}
    
    print(set1 | set2) # all nonduplicate from both the sets 
    print(set1.union(set2)) # all nonduplicate from both the sets 

set intersection - 
class MyTest:
    set1={10, 20, 30, 40, 50}
    set2={40, 50, 60, 70, 80}
    
    print(set1 & set2) # common nonduplicate from both the sets 
    print(set1.intersection(set2)) # common nonduplicate from both the sets 

Set difference - 
class MyTest:
    set1={20, 30, 50, 50, 40}
    set2= {40, 50, 60, 70, 80}
    print(set1-set2) #The element which are in set1 and not in set2
    print(set1.difference(set2))

Set symetric_difference - 
class MyTest:
    set1={20, 30, 50, 50, 40}
    set2= {40, 50, 60, 70, 80}
    print(set1.symmetric_difference(set2)) # Non common element in set1 and set2

Convert the list to set - 
class MyTest:
    array=[20, 30, 50, 50, 40]
    set1=set(array)
    print(set1)

Convert the set to a list - 
class MyTest:
    set={20, 30, 50, 50, 40}
    array1=list(set)
    print(array1)

min, max, sorted operations will be as it is 
class MyTest:
    set={20, 30, 50, 50, 40}
    print(max(set))
    print(min(set))
    print(sorted(set))


#Python directory for file management - 
import os   //This is to play with the folder structure, change dir, create dir

os.mkdir('Test')  // to create Test folder 

print(os.getcwd) // to get the current working dir name 

print(os.listdir) // to get the list of dir in the cwd 

os.chdir('C/data/sushant') // to change the dir

os.rename('Test', 'new data')  // to update the name of the directory 

os.remove('new data.text') // to remove the file 

os.rmdir // to remove the dir 


#Python dictionary (Same as a HashMap in Java) key-value pair elements are stored in the dictionary - 
Declaration - using {} bracket we can declare the dictionary 
class LearnDictioanry:
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    print(oneDict)

print the elements - 
class LearnDictioanry:
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    print(oneDict)
    print(oneDict["MH50"])

We can get the element using get as well 
class LearnDictioanry:
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    print(oneDict.get("MH18"))

Adding new value - 
class LearnDictioanry:
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    print(oneDict)
    oneDict["MH13"]= "Solapur"  // It will add a new key value pair of Solapur
    print(oneDict)

Updating value - 
class LearnDictioanry:
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    oneDict["MH01"]= "Dadar"
    print(oneDict)

removing value - 
class LearnDictioanry:
    Using del
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    del oneDict["MH11"]
    print(oneDict)

Using pop - 
class LearnDictioanry:
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    oneDict.pop("MH11")
    print(oneDict)

Print(key in dic)   
print (key not in dic)   // This will return the True and False it will check for the key present or not 

## Iterating through the directory - 
Using for loop display all the key value of the dictionary - 
class LearnDictioanry:
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    print(oneDict)
  
    for i in oneDict:
        print(i)    // Print all the keys

Using for loop displays all the values in the dictionary - 
class LearnDictioanry:
    oneDict={"MH11":"Satara","MH50":"Karad","MH12":"Pune","MH01":"Mumbai"}
    print(oneDict)
  
    for i in oneDict:
        print(oneDict[i])   // Print all the values 

Len - 
print(len(oneDict))  // To find the length of the dict

Sorted - 
print(sorted(oneDict)   // To sort the dict it sorts only the keys

##Python Strings - 
String is immutable 
String indexing - 
class LearnDictioanry:
    myName="sushant"
    print(myName[0])  // It will print the s 
    print(myName[0:3]) // It will print the sus
    
String concatenation - // Using + operator 
class LearnDictioanry:
    myName="sushant"
    myName2= "Pawar"
    print(myName+" "+myName2)

Using * operator we can multiply the string 
class LearnDictioanry:
    myName="sushant"
    print(myName * 3)  // 3 times Sushant it will print 

We can use in, non in to verify the character/String in the given string, it will return the True or False - 
class LearnDictioanry:
    myName="sushant@gmail.com"
    print("@gmail" in myName) // It will return the True 

Index of the character/String in the String - 
name= "sushant@gmail.com"
print(name.index('@'))  // It will return the index of @

Iterating on String using for loop - 
class LearnDictioanry:
    myName="sushant@gmail.com"
    
    for i in myName:
        if(i=='@'):
            print("Gmail is there in name", myName.index('@'))
            break


.format in the String - 
class LearnDictioanry:
    print("{} {} {}".format('Today is', 'My', "Birthday"))  // We can pass the value in bracket using .format 


String methods - 
name.replace() // print(name.replace("pawar", "Shinde"))
name.upper() //print(name.upper())
name.lower() //print(name.lower())
name.find() // print(name.find("pawar")) // It will find the indexing of pawar like .index

We can convert the string into int - 
Type casting - 
class LearnDictioanry:
    name="432"
    no=123
    noConvert=int (name)  // Converting the string into number
    print(noConvert+no)

type function used to check the data type of the varibale 
class LearnDictioanry:
    name="432"
    no=123
    print(type(name)) //<class 'str'>
    print(type(no))  //<class 'str'>


#Complex class in python - 
no= 50+6j

isinstance 

name= "sushant"
print(isinstance(name, string)) // It will return the True 
print(isinstance(name, int)) // It will return the False

Note - There is some methods to create random numbers string in the python using random method just need to import the random libraries 


#Global, local & nonlocal variable - 

class LearnDictioanry:
 x=5
    
def myFunc():
    global x
    x=10
    print(x)
    
        
myFunc()
print(x)   // It will print the 10 as we decare the varibale as global in local method 

so we can update the global varibale value in local method by intialsing it as a global in the local method 


#Python iterator - 
iter()

class FirstClass:
    iterator={1,2,3,4,5}
    it = iter(iterator)
    print(next(it))
    print(next(it))


#Python Inheritance - 
class child(superclass name)
python supports the multiple inheritance 

class FirstProgram:
    def __init__(self, name):
        self.name=name
        print(f"This is first program name {self.name}")
    def normalMyMethod(self):
        print(f"This is first program name {self.name}")
        
class SecondProgram(FirstProgram):
    def normalMethod(self, name, id):
        self.name=name
        self.id=id
        print(f"This is first program id {self.id}")
        
e= SecondProgram("Pawar") 
e.normalMyMethod()
e.normalMethod("sushant", 1105)
e.normalMyMethod()

Note - Once assinged the value to the self from child it will apply for the parent as well 
In case of multiple inheritance it will always call the method of first class which inherits in terms of same methods 


#Pythong arguments - 
Note - When calling the method by create object then method need a self attribute as well 

class MyTest:
    
    def function_with_arg(self, a, b):
        if a > b:
            return a

obj= MyTest()
print(obj.function_with_arg(50, 30))

We can direct decare the paramater to the function like below - 
class MyTest:
    
    def function_with_arg(self, a=60, b=20):
        if a > b:
            return a

obj= MyTest()
result= obj.function_with_arg()   //No need to pass the arg here as we directly passed those into method 
print(result)


Multiple arguments - Addition of multiple numbers using *args in the parameter 

class MyTest:
    
    def function_with_arg(self, *args):
        sum=0;
        for i in args:
            sum = sum+i
        return sum    

obj=MyTest()
print("The sum is", obj.function_with_arg(1,2,3,4))

#Python continue statment for loop - 
if we want to display the value only on a specific condition that time we can use the continue 
so once we use the continue in the for loop it will not execute further code in for loop it will go and increate the value of i and again check the condition 

e.g to display even number from 1 to 20 
class FirstClass:
    for i in range(1, 20):
        if(i%2!=0):
            continue
        print(i)


#Python errors and Exceptions - 
class FirstClass:
    try:
        a=10
        b=0
        c=a/b

    except ZeroDivisionError:
        print("error")
            
    except TypeError:
        print("Typeerror")

    except:
        print("Default Exceptions")

raise is used to throgh an exception if condition not maches 

class FirstClass:
    try:
      raise ZeroDivisionError

    except ZeroDivisionError:
        print("error")
            
    except TypeError:
        print("Typeerror")
    
    finally:
        print("Default message even after the exceptions")

##Python oops concepts - 
Inheritance 
Encapsulation 
Polymorphism 


##Nested dictinory - 

1. for dictionary we can use the items() method to display the keys and values 
items is a list of all the keys and values in the dictonary 
dict.items()
normalDic= {1: "sushant", 2: "sudhir", 3: "pawar"}

 for i, j in normalDic.items():
        print (j)   // it will print all the values 
        print (i)  // it will print all the keys 

2. For nested dic if we want to take the first keys first values - 

nestedDic= {1:{"name":"sushant", "ID": "1105", "Address":"Pune"}, 2:{"name":"kishor", "ID": "110", "Address":"Karad"}} 
    print("Items from nested disc: ", nestedDic.items())
    
    for i in nestedDic:
        print(nestedDic[i]["name"]) #When want to print the all names in nested dictnory 

3.  nestedDic= {1:{"name":"sushant", "ID": "1105", "Address":"Pune"}, 2:{"name":"kishor", "ID": "110", "Address":"Karad"}} 
    print("Items from nested disc: ", nestedDic.items())
    
    for i, j in nestedDic.items():  // i is a key, j is a value which is again a dic
        print(i)                    // print the keys
        for k in j:                 // inner for loop on values which is dic 
            print(j[k])             // Printing values in nested dic 


## Multilines comments in Python - 
''' this is comments in python for comments ''' or """ this is comments in python for comments  """

#Doc string - 
doc for Python used to add describe methods like a Java doc



##Python Generator - simplicity than an iterator, we can use the generator instead of an iterator 
it returns the iterator objects 
A generator is kind of a return type it stores the value 
and using for loop we can access those values - 

class FirstClass:
    
    def myFunGenerator():
        n=1
        yield n
        
        n=n+1
        yield n
        
        n=n+1
        yield n
    
    for items in myFunGenerator():  //Method names whos returns multiple yield 
        print(items)

Note - Whatever yield returns it prints when we use the for loop for that generator method 


##While loop in Python - 
class FirstClass:
    i=0
    while i<5:
        print(i)
        i=i+1

## if - elif in the Python - 
class FirstClass:
    i=0
    if i>0:
        print("OK")
    elif i<=0 and i==0:
        print("OK with zero")

    else:
        print ("Not Ok no any value is there")


#Two dimensional Array - 
class DemomClass:
    a = [0] * 4   // [0, 0, 0, 0]
    
    a[0] = [1] * 5   // [[1, 1, 1, 1, 1], 0, 0, 0]
    
    print(a)

class FirstClass:
    i=4
    n=3
    a= [0] * i
    for k in range (i):
        a[k]= [1] * n
    print(a)                // [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]


### Regular expression in Python - 
Usages - 
1. Search a specific string out of large amount of data 
2. Search any format of a string for eg phone no, email such type 

import re  // to import the regesx ie regular expression 

1. re.search 
import re
class FirstClass:
    
    if re.search("Pawar", "My name is sushant"):
        print("sushant is in word")
    else:
        print("sushant is not in a word")

2. re.findall

import re
class FirstClass:
    allStrings= re.findall("pawar", "My pawar ispawar pawar")
    count=0
    for i in  allStrings:
        count=count+1
        print(i)
        
    print(count)

3. re.sub   // replace the world in the string 
import re
class FirstClass:
    name= "sushant pawar was in pune"
    
    regex = re.compile("was") #Find the was letter using compiler and sttored
    
    nameFinal= regex.sub("is", name2) # Replace the stored regex with is in a string
    
    print(nameFinal)


## List comprehension - 
list = []
 for i in "sushant":
list.append(i)


#Python recursion - 

#Python file read and write operations - 

Open file 

Read and write file 

close file 

#Python create a new list from existing list - 
if we do using = 
list1=[1, 2, 3]
list2=list1  

and if we add a new element in list1 it will automatically get added into the list2 as well 

so to avid it we can import the copy library import copy 

list2= copy.deepcopy(list1)



